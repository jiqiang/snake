{"version":3,"sources":["types.ts","App.tsx","hooks.ts","serviceWorker.ts","index.tsx"],"names":["CellType","Direction","DirectionKeyCodeMap","ArrowLeft","LEFT","ArrowUp","UP","ArrowRight","RIGHT","ArrowDown","DOWN","Left","Up","Right","Down","OppsiteDirectionKeyCodeMap","Cell","row","col","cellType","this","EMPTY","Board","rowCount","colCount","cells","snakeCells","isGameOver","score","Initialize","GenerateFoodCell","isWallCell","includes","isSnakeCell","WALL","SNAKE","Math","floor","random","GetCellType","SetCellType","FOOD","direction","undefined","nextSnakeHeadCellRow","nextSnakeHeadCellCol","snakeHead","length","GetRow","GetCol","nextCellType","push","snakeTailCell","shift","board","App","useState","GetCells","setCells","setDirection","delay","setDelay","touchStart","setTouchStart","useEffect","document","addEventListener","handleDirectionChange","handleTouchStart","handleTouchEnd","removeEventListener","e","touches","clientX","clientY","horizontalDistance","changedTouches","verticalDistance","abs","dispatchEvent","KeyboardEvent","code","IsGameOver","defaultPrevented","preventDefault","callback","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","console","log","MoveSnake","GetScore","className","map","rowIdx","key","cell","colIdx","onClick","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"+HAAYA,EAOAC,E,sFAPAD,O,iBAAAA,I,eAAAA,I,iBAAAA,I,gBAAAA,M,cAOAC,O,WAAAA,I,eAAAA,I,eAAAA,I,kBAAAA,M,KAOL,IAAMC,EAAwD,CACnEC,UAAWF,EAAUG,KACrBC,QAASJ,EAAUK,GACnBC,WAAYN,EAAUO,MACtBC,UAAWR,EAAUS,KAErBC,KAAMV,EAAUG,KAChBQ,GAAIX,EAAUK,GACdO,MAAOZ,EAAUO,MACjBM,KAAMb,EAAUS,MAGLK,EAA+D,CAC1EZ,UAAWF,EAAUO,MACrBH,QAASJ,EAAUS,KACnBH,WAAYN,EAAUG,KACtBK,UAAWR,EAAUK,GAErBK,KAAMV,EAAUO,MAChBI,GAAIX,EAAUS,KACdG,MAAOZ,EAAUG,KACjBU,KAAMb,EAAUK,IAGLU,EAAb,WAKE,WAAYC,EAAaC,EAAaC,GAAsB,yBAJpDF,SAImD,OAHnDC,SAGmD,OAFnDC,cAEmD,EACzDC,KAAKH,IAAMA,EACXG,KAAKF,IAAMA,EACXE,KAAKD,SAAWA,GAAYnB,EAASqB,MARzC,0DAYI,OAAOD,KAAKD,WAZhB,kCAeqBA,GACjBC,KAAKD,SAAWA,IAhBpB,+BAoBI,OAAOC,KAAKH,MApBhB,+BAwBI,OAAOG,KAAKF,QAxBhB,KA4BaI,EAAb,WAQE,WAAYC,EAAkBC,GAAmB,yBAPzCD,cAOwC,OANxCC,cAMwC,OALxCC,WAKwC,OAJxCC,gBAIwC,OAHxCC,gBAGwC,OAFxCC,WAEwC,EAC9CR,KAAKG,SAAWA,EAChBH,KAAKI,SAAWA,EAChBJ,KAAKK,MAAQ,GACbL,KAAKM,WAAa,CAAC,IAAIV,EAAK,EAAG,IAC/BI,KAAKO,YAAa,EAClBP,KAAKQ,MAAQ,EAEbR,KAAKS,aACLT,KAAKU,mBAjBT,yDAqBI,IAAK,IAAIb,EAAM,EAAGA,EAAMG,KAAKG,SAAUN,IAAO,CAC5CG,KAAKK,MAAMR,GAAO,GAClB,IAAK,IAAIC,EAAM,EAAGA,EAAME,KAAKI,SAAUN,IAAO,CAC5C,IAAMa,EACJ,CAAC,EAAGX,KAAKG,SAAW,GAAGS,SAASf,IAChC,CAAC,EAAGG,KAAKG,SAAW,GAAGS,SAASd,GAC5Be,EAAsB,IAARhB,GAAqB,IAARC,EACjCE,KAAKK,MAAMR,GAAKC,GAAO,IAAIF,EACzBC,EACAC,EACAa,EACI/B,EAASkC,KACTD,EACAjC,EAASmC,MACTnC,EAASqB,WAnCvB,iCA0CI,OAAOD,KAAKQ,QA1ChB,iCA8CI,OAAOR,KAAKK,QA9ChB,mCAkDI,OAAOL,KAAKO,aAlDhB,yCAwDI,IAFA,IAAIV,EAAMmB,KAAKC,MAAMD,KAAKE,UAAYlB,KAAKG,SAAW,IAClDL,EAAMkB,KAAKC,MAAMD,KAAKE,UAAYlB,KAAKI,SAAW,IAEpD,CAACxB,EAASkC,KAAMlC,EAASmC,OAAOH,SAC9BZ,KAAKK,MAAMR,GAAKC,GAAKqB,gBAGvBtB,EAAMmB,KAAKC,MAAMD,KAAKE,UAAYlB,KAAKG,SAAW,IAClDL,EAAMkB,KAAKC,MAAMD,KAAKE,UAAYlB,KAAKI,SAAW,IAEpDJ,KAAKK,MAAMR,GAAKC,GAAKsB,YAAYxC,EAASyC,QAhE9C,gCAmEmBC,GACf,QAAkBC,IAAdD,EAAJ,CAIA,IACIE,EACAC,EAFAC,EAAY1B,KAAKM,WAAWN,KAAKM,WAAWqB,OAAS,GAIzD,OAAQL,GACN,KAAKzC,EAAUO,MACboC,EAAuBE,EAAUE,SAAW,EAC5CH,EAAuBC,EAAUG,SACjC,MACF,KAAKhD,EAAUS,KACbkC,EAAuBE,EAAUE,SACjCH,EAAuBC,EAAUG,SAAW,EAC5C,MACF,KAAKhD,EAAUG,KACbwC,EAAuBE,EAAUE,SAAW,EAC5CH,EAAuBC,EAAUG,SACjC,MACF,KAAKhD,EAAUK,GACbsC,EAAuBE,EAAUE,SACjCH,EAAuBC,EAAUG,SAAW,EAC5C,MACF,QACEL,EAAuBE,EAAUE,SACjCH,EAAuBC,EAAUG,SAGrC,IAAMC,EAAe9B,KAAKK,MAAMmB,GAC9BC,GACAN,cACF,GAAI,CAACvC,EAASkC,KAAMlC,EAASmC,OAAOH,SAASkB,GAC3C9B,KAAKO,YAAa,OAIpB,GACEP,KAAKK,MAAMmB,GAAsBC,GAAsBN,gBACvDvC,EAASyC,KACT,CACArB,KAAKK,MAAMmB,GAAsBC,GAAsBL,YACrDxC,EAASmC,OAEXf,KAAKM,WAAWyB,KACd,IAAInC,EAAK4B,EAAsBC,IAGjC,IAAMO,EAAgBhC,KAAKM,WAAW2B,QAClCD,GACFhC,KAAKK,MAAM2B,EAAcJ,UAAUI,EAAcH,UAAUT,YACzDxC,EAASqB,YAIbD,KAAKK,MAAMmB,GAAsBC,GAAsBL,YACrDxC,EAASmC,OAEXf,KAAKM,WAAWyB,KACd,IAAInC,EAAK4B,EAAsBC,IAEjCzB,KAAKU,mBACLV,KAAKQ,aAnIX,KCtDI0B,EAAQ,IAAIhC,EAAM,GAAI,IAiJXiC,EA/IH,WAAO,IAAD,EACUC,mBAAmBF,EAAMG,YADnC,mBACThC,EADS,KACFiC,EADE,OAEkBF,wBAAgCb,GAFlD,mBAETD,EAFS,KAEEiB,EAFF,OAGUH,wBAA6Bb,GAHvC,mBAGTiB,EAHS,KAGFC,EAHE,OAIoBL,mBAA2B,CAAC,EAAG,IAJnD,mBAITM,EAJS,KAIGC,EAJH,KAMhBC,qBAAU,WAIR,OAHAC,SAASC,iBAAiB,UAAWC,GACrCF,SAASC,iBAAiB,aAAcE,GACxCH,SAASC,iBAAiB,WAAYG,GAC/B,WACLJ,SAASK,oBAAoB,UAAWH,GACxCF,SAASK,oBAAoB,aAAcF,GAC3CH,SAASK,oBAAoB,WAAYD,OAI7C,IAAMD,EAAmB,SAACG,GACxBR,EAAc,CAACQ,EAAEC,QAAQ,GAAGC,QAASF,EAAEC,QAAQ,GAAGE,WAG9CL,EAAiB,SAACE,GACtB,IAAMI,EAAqBJ,EAAEK,eAAe,GAAGH,QAAUX,EAAW,GAC9De,EAAmBN,EAAEK,eAAe,GAAGF,QAAUZ,EAAW,GAE9D1B,KAAK0C,IAAIH,IAAuBvC,KAAK0C,IAAID,GACvCA,GAAoB,EACtBZ,SAASc,cACP,IAAIC,cAAc,UAAW,CAAEC,KAAM,aAGvChB,SAASc,cACP,IAAIC,cAAc,UAAW,CAAEC,KAAM,eAIrCN,GAAsB,EACxBV,SAASc,cACP,IAAIC,cAAc,UAAW,CAAEC,KAAM,eAGvChB,SAASc,cACP,IAAIC,cAAc,UAAW,CAAEC,KAAM,iBAMvCd,EAAwB,SAACI,GAC7B,IAAIjB,EAAM4B,oBAIIvC,IAAViB,GACFC,EAAS,MAGPU,EAAEY,kBAKFjF,EAAoBqE,EAAEU,QAAUvC,GAKhC3B,EAA2BwD,EAAEU,QAAUvC,GAA3C,CAIA,OAAQ6B,EAAEU,MACR,IAAK,OACL,IAAK,YAEHtB,EAAa1D,EAAUS,MACvB,MACF,IAAK,KACL,IAAK,UAEHiD,EAAa1D,EAAUK,IACvB,MACF,IAAK,OACL,IAAK,YAEHqD,EAAa1D,EAAUG,MACvB,MACF,IAAK,QACL,IAAK,aAEHuD,EAAa1D,EAAUO,OACvB,MACF,QACE,OAIJ+D,EAAEa,oBC7GqB,SAACC,EAAezB,GACzC,IAAM0B,EAAqBC,mBAG3BvB,qBAAU,WACRsB,EAAcE,QAAUH,IACvB,CAACA,IAGJrB,qBAAU,WACR,IAGIyB,EACJ,QAAc9C,IAAViB,EAEF,OADA6B,EAAKC,aALM,WACXJ,EAAcE,YAIS5B,GAChB,kBAAM+B,cAAcF,MAE5B,CAAC7B,ID8FJgC,EAAY,WACVC,QAAQC,IAAI,QACZxC,EAAMyC,UAAUrD,GACZY,EAAM4B,cACRrB,OAASlB,GAEXe,EAAS,YAAIJ,EAAMG,eAClBG,GAUH,OACE,oCACE,uCAAaN,EAAM0C,YACnB,yBAAKC,UAAU,SACZxE,EAAMyE,KAAI,SAACjF,EAAKkF,GAAN,OACT,yBAAKF,UAAU,MAAMG,IAAG,cAASD,IAC9BlF,EAAIiF,KAAI,SAACG,EAAMC,GAAP,OACP,yBAAKL,UAAU,MAAMG,IAAG,cAASE,IAC/B,yBACEL,UAAS,eAAUI,EAAK9D,gBAAkBvC,EAASyC,MACjD,UADO,YACM4D,EAAK9D,gBAAkBvC,EAASmC,OAC7C,WAFO,YAEOkE,EAAK9D,gBAAkBvC,EAASkC,MAC9C,sBAOd,yBAAK+D,UAAU,UAAUM,QA3BP,WACpBjD,EAAQ,IAAIhC,EAAM,GAAI,IACtBoC,EAASJ,EAAMG,YACfE,OAAahB,GACbkB,OAASlB,GACToB,EAAc,CAAC,EAAG,MAuBd,8CE3IYyC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAAS7C,SAAS8C,eAAe,SDqI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL1B,QAAQ0B,MAAMA,EAAMC,a","file":"static/js/main.a85ab688.chunk.js","sourcesContent":["export enum CellType {\n  EMPTY,\n  FOOD,\n  SNAKE,\n  WALL\n}\n\nexport enum Direction {\n  UP,\n  DOWN,\n  LEFT,\n  RIGHT\n}\n\nexport const DirectionKeyCodeMap: { [keyCode: string]: Direction } = {\n  ArrowLeft: Direction.LEFT,\n  ArrowUp: Direction.UP,\n  ArrowRight: Direction.RIGHT,\n  ArrowDown: Direction.DOWN,\n  // for IE\n  Left: Direction.LEFT,\n  Up: Direction.UP,\n  Right: Direction.RIGHT,\n  Down: Direction.DOWN\n};\n\nexport const OppsiteDirectionKeyCodeMap: { [keyCode: string]: Direction } = {\n  ArrowLeft: Direction.RIGHT,\n  ArrowUp: Direction.DOWN,\n  ArrowRight: Direction.LEFT,\n  ArrowDown: Direction.UP,\n  // for IE\n  Left: Direction.RIGHT,\n  Up: Direction.DOWN,\n  Right: Direction.LEFT,\n  Down: Direction.UP\n};\n\nexport class Cell {\n  private row: number;\n  private col: number;\n  private cellType: CellType;\n\n  constructor(row: number, col: number, cellType?: CellType) {\n    this.row = row;\n    this.col = col;\n    this.cellType = cellType || CellType.EMPTY;\n  }\n\n  public GetCellType(): CellType {\n    return this.cellType;\n  }\n\n  public SetCellType(cellType: CellType): void {\n    this.cellType = cellType;\n  }\n\n  public GetRow(): number {\n    return this.row;\n  }\n\n  public GetCol(): number {\n    return this.col;\n  }\n}\n\nexport class Board {\n  private rowCount: number;\n  private colCount: number;\n  private cells: Cell[][];\n  private snakeCells: Cell[];\n  private isGameOver: boolean;\n  private score: number;\n\n  constructor(rowCount: number, colCount: number) {\n    this.rowCount = rowCount;\n    this.colCount = colCount;\n    this.cells = [];\n    this.snakeCells = [new Cell(2, 2)];\n    this.isGameOver = false;\n    this.score = 0;\n\n    this.Initialize();\n    this.GenerateFoodCell();\n  }\n\n  public Initialize(): void {\n    for (let row = 0; row < this.rowCount; row++) {\n      this.cells[row] = [];\n      for (let col = 0; col < this.colCount; col++) {\n        const isWallCell =\n          [0, this.rowCount - 1].includes(row) ||\n          [0, this.rowCount - 1].includes(col);\n        const isSnakeCell = row === 2 && col === 2;\n        this.cells[row][col] = new Cell(\n          row,\n          col,\n          isWallCell\n            ? CellType.WALL\n            : isSnakeCell\n            ? CellType.SNAKE\n            : CellType.EMPTY\n        );\n      }\n    }\n  }\n\n  public GetScore(): number {\n    return this.score;\n  }\n\n  public GetCells(): Cell[][] {\n    return this.cells;\n  }\n\n  public IsGameOver(): boolean {\n    return this.isGameOver;\n  }\n\n  public GenerateFoodCell(): void {\n    let row = Math.floor(Math.random() * (this.rowCount - 1));\n    let col = Math.floor(Math.random() * (this.colCount - 1));\n    while (\n      [CellType.WALL, CellType.SNAKE].includes(\n        this.cells[row][col].GetCellType()\n      )\n    ) {\n      row = Math.floor(Math.random() * (this.rowCount - 1));\n      col = Math.floor(Math.random() * (this.colCount - 1));\n    }\n    this.cells[row][col].SetCellType(CellType.FOOD);\n  }\n\n  public MoveSnake(direction: Direction | undefined) {\n    if (direction === undefined) {\n      return;\n    }\n\n    let snakeHead = this.snakeCells[this.snakeCells.length - 1];\n    let nextSnakeHeadCellRow: number;\n    let nextSnakeHeadCellCol: number;\n\n    switch (direction) {\n      case Direction.RIGHT:\n        nextSnakeHeadCellRow = snakeHead.GetRow() + 1;\n        nextSnakeHeadCellCol = snakeHead.GetCol();\n        break;\n      case Direction.DOWN:\n        nextSnakeHeadCellRow = snakeHead.GetRow();\n        nextSnakeHeadCellCol = snakeHead.GetCol() + 1;\n        break;\n      case Direction.LEFT:\n        nextSnakeHeadCellRow = snakeHead.GetRow() - 1;\n        nextSnakeHeadCellCol = snakeHead.GetCol();\n        break;\n      case Direction.UP:\n        nextSnakeHeadCellRow = snakeHead.GetRow();\n        nextSnakeHeadCellCol = snakeHead.GetCol() - 1;\n        break;\n      default:\n        nextSnakeHeadCellRow = snakeHead.GetRow();\n        nextSnakeHeadCellCol = snakeHead.GetCol();\n    }\n\n    const nextCellType = this.cells[nextSnakeHeadCellRow][\n      nextSnakeHeadCellCol\n    ].GetCellType();\n    if ([CellType.WALL, CellType.SNAKE].includes(nextCellType)) {\n      this.isGameOver = true;\n      return;\n    }\n\n    if (\n      this.cells[nextSnakeHeadCellRow][nextSnakeHeadCellCol].GetCellType() !==\n      CellType.FOOD\n    ) {\n      this.cells[nextSnakeHeadCellRow][nextSnakeHeadCellCol].SetCellType(\n        CellType.SNAKE\n      );\n      this.snakeCells.push(\n        new Cell(nextSnakeHeadCellRow, nextSnakeHeadCellCol)\n      );\n\n      const snakeTailCell = this.snakeCells.shift();\n      if (snakeTailCell) {\n        this.cells[snakeTailCell.GetRow()][snakeTailCell.GetCol()].SetCellType(\n          CellType.EMPTY\n        );\n      }\n    } else {\n      this.cells[nextSnakeHeadCellRow][nextSnakeHeadCellCol].SetCellType(\n        CellType.SNAKE\n      );\n      this.snakeCells.push(\n        new Cell(nextSnakeHeadCellRow, nextSnakeHeadCellCol)\n      );\n      this.GenerateFoodCell();\n      this.score++;\n    }\n  }\n}\n","import React, { useState, useEffect } from \"react\";\nimport \"./App.css\";\nimport {\n  CellType,\n  Board,\n  Cell,\n  Direction,\n  DirectionKeyCodeMap,\n  OppsiteDirectionKeyCodeMap\n} from \"./types\";\nimport { useInterval } from \"./hooks\";\n\nlet board = new Board(30, 30);\n\nconst App = () => {\n  const [cells, setCells] = useState<Cell[][]>(board.GetCells());\n  const [direction, setDirection] = useState<Direction | undefined>(undefined);\n  const [delay, setDelay] = useState<number | undefined>(undefined);\n  const [touchStart, setTouchStart] = useState<[number, number]>([0, 0]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleDirectionChange);\n    document.addEventListener(\"touchstart\", handleTouchStart);\n    document.addEventListener(\"touchend\", handleTouchEnd);\n    return () => {\n      document.removeEventListener(\"keydown\", handleDirectionChange);\n      document.removeEventListener(\"touchstart\", handleTouchStart);\n      document.removeEventListener(\"touchend\", handleTouchEnd);\n    };\n  });\n\n  const handleTouchStart = (e: TouchEvent) => {\n    setTouchStart([e.touches[0].clientX, e.touches[0].clientY]);\n  };\n\n  const handleTouchEnd = (e: TouchEvent) => {\n    const horizontalDistance = e.changedTouches[0].clientX - touchStart[0];\n    const verticalDistance = e.changedTouches[0].clientY - touchStart[1];\n\n    if (Math.abs(horizontalDistance) <= Math.abs(verticalDistance)) {\n      if (verticalDistance <= 0) {\n        document.dispatchEvent(\n          new KeyboardEvent(\"keydown\", { code: \"ArrowUp\" })\n        );\n      } else {\n        document.dispatchEvent(\n          new KeyboardEvent(\"keydown\", { code: \"ArrowDown\" })\n        );\n      }\n    } else {\n      if (horizontalDistance <= 0) {\n        document.dispatchEvent(\n          new KeyboardEvent(\"keydown\", { code: \"ArrowLeft\" })\n        );\n      } else {\n        document.dispatchEvent(\n          new KeyboardEvent(\"keydown\", { code: \"ArrowRight\" })\n        );\n      }\n    }\n  };\n\n  const handleDirectionChange = (e: KeyboardEvent) => {\n    if (board.IsGameOver()) {\n      return;\n    }\n\n    if (delay === undefined) {\n      setDelay(100);\n    }\n\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    // Do nothing if it is same to previous direction\n    if (DirectionKeyCodeMap[e.code] === direction) {\n      return;\n    }\n\n    // Do nothin if previous direction is oppsite direction of current one\n    if (OppsiteDirectionKeyCodeMap[e.code] === direction) {\n      return;\n    }\n\n    switch (e.code) {\n      case \"Down\": // IE/Edge specific value\n      case \"ArrowDown\":\n        // Do something for \"down arrow\" key press.\n        setDirection(Direction.DOWN);\n        break;\n      case \"Up\": // IE/Edge specific value\n      case \"ArrowUp\":\n        // Do something for \"up arrow\" key press.\n        setDirection(Direction.UP);\n        break;\n      case \"Left\": // IE/Edge specific value\n      case \"ArrowLeft\":\n        // Do something for \"left arrow\" key press.\n        setDirection(Direction.LEFT);\n        break;\n      case \"Right\": // IE/Edge specific value\n      case \"ArrowRight\":\n        // Do something for \"right arrow\" key press.\n        setDirection(Direction.RIGHT);\n        break;\n      default:\n        return; // Quit when this doesn't handle the key event.\n    }\n\n    // Cancel the default action to avoid it being handled twice\n    e.preventDefault();\n  };\n\n  useInterval(() => {\n    console.log(\"tick\");\n    board.MoveSnake(direction);\n    if (board.IsGameOver()) {\n      setDelay(undefined);\n    }\n    setCells([...board.GetCells()]);\n  }, delay);\n\n  const handleRestart = () => {\n    board = new Board(30, 30);\n    setCells(board.GetCells());\n    setDirection(undefined);\n    setDelay(undefined);\n    setTouchStart([0, 0]);\n  };\n\n  return (\n    <>\n      <h3>Scores: {board.GetScore()}</h3>\n      <div className=\"board\">\n        {cells.map((row, rowIdx) => (\n          <div className=\"row\" key={`row-${rowIdx}`}>\n            {row.map((cell, colIdx) => (\n              <div className=\"col\" key={`col-${colIdx}`}>\n                <div\n                  className={`cell ${cell.GetCellType() === CellType.FOOD &&\n                    \"is-food\"} ${cell.GetCellType() === CellType.SNAKE &&\n                    \"is-snake\"} ${cell.GetCellType() === CellType.WALL &&\n                    \"is-wall\"}`}\n                ></div>\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n      <div className=\"restart\" onClick={handleRestart}>\n        <button>Restart</button>\n      </div>\n    </>\n  );\n};\n\nexport default App;\n","import { useEffect, useRef } from \"react\";\n\nexport const useInterval = (callback: any, delay: number | undefined) => {\n  const savedCallback: any = useRef<any>();\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    const tick = () => {\n      savedCallback.current();\n    };\n    let id: any;\n    if (delay !== undefined) {\n      id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'normalize.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}